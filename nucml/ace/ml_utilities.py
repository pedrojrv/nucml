"""Data utilities for hybrid ML-aided Cross Section evaluations."""
import os
import numpy as np
import pandas as pd
from scipy.signal import find_peaks

from nucml import configure

import nucml.model.utilities as model_utils
import nucml.exfor.data_utilities as exfor_utils
import nucml.ace.serpent_utilities as serpent_utils
import nucml.ace.data_utilities as ace_utils
import nucml.ace.querying_utils as query_utils
import nucml.general_utilities as gen_utils


config = configure._get_config()
template_path = config['BENCHMARKING_TEMPLATE_PATH']


def fill_ml_xs(MT, ml_xs, ace_xs, use_peaks=True):
    """Fill in the head and tail of a set of cross section values using the hybrid approach.

    Args:
        MT (int): ENDF MT reaction code for the reaction channel to adjust.
        ml_xs (DataFrame): The DataFrame containing the cross section values for the MT reaction to adjust.
        ace_xs (np.array): Array containing the ENDF cross sections that will be used to fill in the ml_xs DataFrame.

    Returns:
        DataFrame: Adjusted ml_xs DataFrame.
    """
    if use_peaks:
        fallback = False
        peaks, properties = find_peaks(ace_xs, prominence=1, width=5)
        if len(peaks) == 0:
            fallback = True
        else:
            properties["prominences"], properties["widths"]
            to_append = ace_xs[:peaks[0]]
            new_xs = np.concatenate((to_append, ml_xs[MT][peaks[0]:].values), axis=0)
            ml_xs[MT] = new_xs

    if fallback or not use_peaks:
        # FILLS VALUES IN ML DERIVED XS WHERE ALGORITHM IS UNABLE TO PERFORM (1/V AND TAIL)
        # FOR ALL VALUES THE SAME AS THE FIRST AND LAST ONE SUBSTITUTE FOR EQUIVALENT VALUE IN ENERGY IN ACE XS
        ml_xs.loc[0:ml_xs[ml_xs[MT] == ml_xs[MT].values[0]].shape[0], MT] = ace_xs[
            0:ml_xs[ml_xs[MT] == ml_xs[MT].values[0]].shape[0]+1]
        ml_xs.iloc[-ml_xs[ml_xs[MT] == ml_xs[MT].values[-1]].shape[0]:, ml_xs.columns.get_loc(MT)] = ace_xs[
            -ml_xs[ml_xs[MT] == ml_xs[MT].values[-1]].shape[0] - 1:-1]
    return ml_xs


def get_hybrid_ml_xs(ml_df, pointers, jxs_df, xss, use_peaks=True):
    """Substitutes the ACE MT values in a machine learning generate dataframe containing a set of reaction channels.

    For MT1, MT2, and MT3 we fix the 1/v and tail region of each cross section.
    ML models like KNN and DT are coarse and sometimes unable to accuratly keep predicting a given
    trend. For this we:

    Args:
        ml_df (DataFrame): Contains the ML generated predictions under each columned named "MT_MT".
        basic_mt_dict (DICT): A dicitonary containing MT1, MT2, MT3, and MT101 ({"mt1":values, "mt2":...}).
        mt_array (np.array): Contains the mt reactions avaliable in the .ace file.
        mt_xs_pointers_array (np.array): Contains the mt XS pointers in the xss array.
        xs_table_pointer (int): Index at which XS's start in the xss array.
        jxs_df (DataFrame): The DataFrame obtained using the get_nxs_jxs_xss() function.
        xss (np.array): Array containing all information in the .ace file.

    Returns:
        DataFrame: Merged DataFrame containing all ML and ACE reaction values.
    """
    basic_mt_dict = query_utils.get_basic_mts(xss, pointers)
    mt_array = query_utils.get_mt_array(xss, pointers)
    mt_xs_pointers_array = query_utils.get_mt_xs_pointers_array(xss, pointers)

    for i in list(ml_df.columns):
        MT = i.split("_")[1]
        if i == "Energy":
            continue
        elif i in ["MT_1", "MT_2", "MT_3", "MT_101"]:
            ml_df = fill_ml_xs(i, ml_df, basic_mt_dict[i], use_peaks=use_peaks)
        elif i in ["MT_18", "MT_102"]:
            mt_info = query_utils.get_xs_for_mt(int(MT), mt_array, mt_xs_pointers_array, jxs_df, xss, pointers)
            ml_df = fill_ml_xs(i, ml_df, mt_info["xs"], use_peaks=use_peaks)
        elif MT in mt_array:
            mt_info = query_utils.get_xs_for_mt(int(MT), mt_array, mt_xs_pointers_array, jxs_df, xss, pointers)
            new_xs = np.concatenate((np.zeros(mt_info["energy_start"]), mt_info["xs"]), axis=0)
            ml_df[i] = new_xs
    return ml_df


def get_final_ml_ace_df(energies, pointers, jxs_df, xss, ml_df,
                        ml_list=["MT_1", "MT_2", "MT_3", "MT_18", "MT_101", "MT_102"]):
    """Given a set of ML generated XS (adjusted), fill in other reaction channels not included by the ML predictions.

    This is useful since for some calculations some MT reactions are not required but are still
    present in the ACE files. This allows to preserve the ACE file values and structure.

    For MT3 the ML generated cross sections are adjusted so that conservation rules are not broken. Same for MT101.
    All values will be at the energy grid specified by the energies array.

    Note: MT2 is not calculated here.

    TODO: DEAL WITH MT3 BETTER IN CASE IT IS GENERATED BY ML, WHAT ELSE TO ADJUST

    Args:
        energies (np.array): Array containing the energy values at which the ML generated values are created.
        mt_array (np.array): Array containing all mt reactions avaliable in ACE.
        mt_xs_pointers_array (np.array): Pointers for every reaction in the MT array in the XSS array.
        xs_table_pointer (int): Index of xxs at which the XS values start.
        jxs_df (DataFrame): The DataFrame containing the JXS table.
        xss (np.array): Array containing all info for a specific ace file.
        ml_df (DataFrame): DataFrame containing the ML generated cross sections.
        ml_list (list): List containing the ML generated column names that should not be modified at any point.

    Returns:
        DataFrame: DataFrame containing the resulting cross sections from both ML and ACE.
    """
    Energy_Grid = pd.DataFrame({"Energy": energies}).set_index("Energy")

    mt_array = query_utils.get_mt_array(xss, pointers)
    mt_xs_pointers_array = query_utils.get_mt_xs_pointers_array(xss, pointers)
    for i in mt_array:
        # we get the ace cross sections and add them to our main dataframe some are not going to have the
        # same energy grid as mt1 so we fill missing values with 0
        mt_info = query_utils.get_xs_for_mt(i, mt_array, mt_xs_pointers_array, jxs_df, xss, pointers)
        to_add = pd.DataFrame({"Energy": mt_info["energy"], "MT_" + str(int(i)): mt_info["xs"]}).set_index("Energy")
        Energy_Grid = pd.merge(Energy_Grid, to_add, left_index=True, right_index=True, how="outer")
    Energy_Grid = Energy_Grid.fillna(value=0)

    for i in ml_list:
        # Once the ace XS are in a dataframe we can substitute the ace xs by those of ml
        Energy_Grid[i] = ml_df[i].values

    # MT3 and MT101 are dependant on a bunch of other MTs, we need to adjust them in order for
    # the conservation rules to be mantained.
    # Energy_Grid["MT_3"] = create_mt(Energy_Grid, "MT_3", mt_array)
    # Energy_Grid["MT_101"] = create_mt(Energy_Grid, "MT_101", mt_array)
    Energy_Grid = ace_utils.create_mt2_mt3_mt101(Energy_Grid, mt_array)
    Energy_Grid = ace_utils.enforce_unitarity(Energy_Grid)
    return Energy_Grid


def _get_model_and_scaler(normalizer, model_path, scaler_path):
    if normalizer == "none":
        model = model_utils.load_model_and_scaler(
            {"model_path": model_path, "scaler_path": scaler_path}, df=False, model_only=True)
        scaler = None
    else:
        model, scaler = model_utils.load_model_and_scaler(
            {"model_path": model_path, "scaler_path": scaler_path}, df=False)
    return model, scaler


def generate_bench_ml_xs(df, models_df, bench_name, to_scale, raw_saving_dir, template_dir=template_path,
                         comp_threshold=0.10):
    """Generate cross section files using ML-generated values."""
    to_scale_copy = to_scale.copy()
    results_df = models_df.copy()
    bench_composition = pd.read_csv(os.path.join(template_dir, os.path.join(bench_name, "composition.csv")))
    bench_composition_nonml = bench_composition[bench_composition.Fraction < comp_threshold]
    bench_composition_ml = bench_composition[bench_composition.Fraction > comp_threshold]

    results_df["run_name"] = results_df.model_path.apply(lambda x: os.path.basename(os.path.dirname(x)))

    scale_energy_col = True if "scale_energy" in results_df.columns else False
    # 3. We iterate over the rows to create data for each run
    for _, row in results_df.iterrows():
        to_scale = to_scale_copy.copy()
        run_name = row.run_name

        # 3a. We create a directory for each model but before we check if it has already been created in the inventory
        bench_saving_dir = os.path.abspath(os.path.join(raw_saving_dir, run_name + "/" + bench_name + "/"))
        ml_xs_saving_dir = os.path.join(bench_saving_dir, "ml_xs_csv")
        acelib_saving_dir = os.path.join(bench_saving_dir, "acelib")

        gen_utils.initialize_directories(bench_saving_dir, reset=True)
        gen_utils.initialize_directories([ml_xs_saving_dir, acelib_saving_dir], reset=True)

        model, scaler = _get_model_and_scaler(row.normalizer, row.model_path, row.scaler_path)

        if scale_energy_col and row.scale_energy:
            to_scale = ["Energy"] + to_scale

        for _, comp_row in bench_composition_ml.iterrows():
            Z, A = int(comp_row.Z), int(comp_row.A)
            filename = "{}{}_ml.csv".format(Z, A)
            path_to_ml_csv = os.path.join(ml_xs_saving_dir, filename)
            if os.path.isfile(path_to_ml_csv):
                continue

            data_ace = exfor_utils.get_csv_for_ace(df, Z, A, model, scaler, to_scale)
            data_ace.to_csv(path_to_ml_csv)

            ace_utils.create_new_ace_w_df(
                str(Z) + str(A).zfill(3), path_to_ml_csv, saving_dir=acelib_saving_dir, ignore_basename=True)

        bench_composition_nonml["ZA"] = bench_composition_nonml.Z.astype(str) + bench_composition_nonml.A.astype(str)
        for _, comp_row in bench_composition_nonml.iterrows():
            ace_utils.copy_ace_w_name(comp_row.ZA, acelib_saving_dir)

        ace_utils.generate_sss_xsdata(bench_saving_dir)
        serpent_utils.copy_benchmark_files(bench_name, bench_saving_dir)
        ace_utils.reduce_ace_filesize(bench_saving_dir)
